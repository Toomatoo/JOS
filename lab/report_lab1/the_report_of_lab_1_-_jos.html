<!DOCTYPE html>  
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>the_report_of_lab_1_-_jos</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
/*
This document has been created with Marked.app <http://markedapp.com>, Copyright 2013 Brett Terpstra
Content is property of the document author
Please leave this notice in place, along with any additional credits below.
---------------------------------------------------------------
Title: GitHub
Author: Brett Terpstra
Description: Github README style. Includes theme for Pygmentized code blocks.
*/
html,body{color:black}*:not('#mkdbuttons'){margin:0;padding:0}#wrapper{font:13.34px helvetica,arial,freesans,clean,sans-serif;-webkit-font-smoothing:subpixel-antialiased;line-height:1.4;padding:3px;background:#fff;border-radius:3px;-moz-border-radius:3px;-webkit-border-radius:3px}p{margin:1em 0}a{color:#4183c4;text-decoration:none}#wrapper{background-color:#fff;padding:30px;margin:15px;font-size:14px;line-height:1.6}#wrapper>*:first-child{margin-top:0!important}#wrapper>*:last-child{margin-bottom:0!important}@media screen{#wrapper{box-shadow:0 0 0 1px #cacaca,0 0 0 4px #eee}}h1,h2,h3,h4,h5,h6{margin:20px 0 10px;padding:0;font-weight:bold;-webkit-font-smoothing:subpixel-antialiased;cursor:text}h1{font-size:28px;color:#000}h2{font-size:24px;border-bottom:1px solid #ccc;color:#000}h3{font-size:18px;color:#333}h4{font-size:16px;color:#333}h5{font-size:14px;color:#333}h6{color:#777;font-size:14px}p,blockquote,table,pre{margin:15px 0}ul{padding-left:30px}ol{padding-left:30px}ol li ul:first-of-type{margin-top:0}hr{background:transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;border:0 none;color:#ccc;height:4px;padding:0}#wrapper>h2:first-child{margin-top:0;padding-top:0}#wrapper>h1:first-child{margin-top:0;padding-top:0}#wrapper>h1:first-child+h2{margin-top:0;padding-top:0}#wrapper>h3:first-child,#wrapper>h4:first-child,#wrapper>h5:first-child,#wrapper>h6:first-child{margin-top:0;padding-top:0}a:first-child h1,a:first-child h2,a:first-child h3,a:first-child h4,a:first-child h5,a:first-child h6{margin-top:0;padding-top:0}h1+p,h2+p,h3+p,h4+p,h5+p,h6+p,ul li>:first-child,ol li>:first-child{margin-top:0}dl{padding:0}dl dt{font-size:14px;font-weight:bold;font-style:italic;padding:0;margin:15px 0 5px}dl dt:first-child{padding:0}dl dt>:first-child{margin-top:0}dl dt>:last-child{margin-bottom:0}dl dd{margin:0 0 15px;padding:0 15px}dl dd>:first-child{margin-top:0}dl dd>:last-child{margin-bottom:0}blockquote{border-left:4px solid #DDD;padding:0 15px;color:#777}blockquote>:first-child{margin-top:0}blockquote>:last-child{margin-bottom:0}table{border-collapse:collapse;border-spacing:0;font-size:100%;font:inherit}table th{font-weight:bold;border:1px solid #ccc;padding:6px 13px}table td{border:1px solid #ccc;padding:6px 13px}table tr{border-top:1px solid #ccc;background-color:#fff}table tr:nth-child(2n){background-color:#f8f8f8}img{max-width:100%}code,tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px;font-family:Consolas,'Liberation Mono',Courier,monospace;font-size:12px;color:#333}pre>code{margin:0;padding:0;white-space:pre;border:0;background:transparent}.highlight pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre code,pre tt{background-color:transparent;border:0}.poetry pre{font-family:Georgia,Garamond,serif!important;font-style:italic;font-size:110%!important;line-height:1.6em;display:block;margin-left:1em}.poetry pre code{font-family:Georgia,Garamond,serif!important;word-break:break-all;word-break:break-word;-webkit-hyphens:auto;-moz-hyphens:auto;hyphens:auto;white-space:pre-wrap}sup,sub,a.footnote{font-size:1.4ex;height:0;line-height:1;vertical-align:super;position:relative}sub{vertical-align:sub;top:-1px}@media print{body{background:#fff}img,pre,blockquote,table,figure{page-break-inside:avoid}#wrapper{background:#fff;border:0}code{background-color:#fff;color:#333!important;padding:0 .2em;border:1px solid #dedede}pre{background:#fff}pre code{background-color:white!important;overflow:visible}}@media screen{body.inverted{color:#eee!important;border-color:#555;box-shadow:none}.inverted #wrapper,.inverted hr .inverted p,.inverted td,.inverted li,.inverted h1,.inverted h2,.inverted h3,.inverted h4,.inverted h5,.inverted h6,.inverted th,.inverted .math,.inverted caption,.inverted dd,.inverted dt,.inverted blockquote{color:#eee!important;border-color:#555;box-shadow:none}.inverted td,.inverted th{background:#333}.inverted pre,.inverted code,.inverted tt{background:#444!important;border-color:#111}.inverted h2{border-color:#555}.inverted hr{border-color:#777;border-width:1px!important}::selection{background:rgba(157,193,200,0.5)}h1::selection{background-color:rgba(45,156,208,0.3)}h2::selection{background-color:rgba(90,182,224,0.3)}h3::selection,h4::selection,h5::selection,h6::selection,li::selection,ol::selection{background-color:rgba(133,201,232,0.3)}code::selection{background-color:rgba(0,0,0,0.7);color:#eee}code span::selection{background-color:rgba(0,0,0,0.7)!important;color:#eee!important}a::selection{background-color:rgba(255,230,102,0.2)}.inverted a::selection{background-color:rgba(255,230,102,0.6)}td::selection,th::selection,caption::selection{background-color:rgba(180,237,95,0.5)}.inverted{background:#0b2531;background:#252a2a}.inverted #wrapper{background:#252a2a}.inverted a{color:#acd1d5}}.highlight .c{color:#998;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .k,.highlight .o{font-weight:bold}.highlight .cm{color:#998;font-style:italic}.highlight .cp{color:#999;font-weight:bold}.highlight .c1{color:#998;font-style:italic}.highlight .cs{color:#999;font-weight:bold;font-style:italic}.highlight .gd{color:#000;background-color:#fdd}.highlight .gd .x{color:#000;background-color:#faa}.highlight .ge{font-style:italic}.highlight .gr{color:#a00}.highlight .gh{color:#999}.highlight .gi{color:#000;background-color:#dfd}.highlight .gi .x{color:#000;background-color:#afa}.highlight .go{color:#888}.highlight .gp{color:#555}.highlight .gs{font-weight:bold}.highlight .gu{color:#800080;font-weight:bold}.highlight .gt{color:#a00}.highlight .kc,.highlight .kd,.highlight .kn,.highlight .kp,.highlight .kr{font-weight:bold}.highlight .kt{color:#458;font-weight:bold}.highlight .m{color:#099}.highlight .s{color:#d14}.highlight .na{color:#008080}.highlight .nb{color:#0086b3}.highlight .nc{color:#458;font-weight:bold}.highlight .no{color:#008080}.highlight .ni{color:#800080}.highlight .ne,.highlight .nf{color:#900;font-weight:bold}.highlight .nn{color:#555}.highlight .nt{color:#000080}.highlight .nv{color:#008080}.highlight .ow{font-weight:bold}.highlight .w{color:#bbb}.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo{color:#099}.highlight .sb,.highlight .sc,.highlight .sd,.highlight .s2,.highlight .se,.highlight .sh,.highlight .si,.highlight .sx{color:#d14}.highlight .sr{color:#009926}.highlight .s1{color:#d14}.highlight .ss{color:#990073}.highlight .bp{color:#999}.highlight .vc,.highlight .vg,.highlight .vi{color:#008080}.highlight .il{color:#099}.highlight .gc{color:#999;background-color:#eaf2f5}.type-csharp .highlight .k,.type-csharp .highlight .kt{color:#00F}.type-csharp .highlight .nf{color:#000;font-weight:normal}.type-csharp .highlight .nc{color:#2b91af}.type-csharp .highlight .nn{color:#000}.type-csharp .highlight .s,.type-csharp .highlight .sc{color:#a31515}/*

Zenburn style from voldmar.ru (c) Vladimir Epifanov <voldmar@voldmar.ru>
based on dark.css by Ivan Sagalaev

*/

pre code {
  display: block; padding: 0.5em;
  background: #3F3F3F;
  color: #DCDCDC;
}

pre .keyword,
pre .tag,
pre .django .tag,
pre .django .keyword,
pre .css .class,
pre .css .id,
pre .lisp .title {
  color: #E3CEAB;
}

pre .django .template_tag,
pre .django .variable,
pre .django .filter .argument {
  color: #DCDCDC;
}

pre .number,
pre .date {
  color: #8CD0D3;
}

pre .dos .envvar,
pre .dos .stream,
pre .variable,
pre .apache .sqbracket {
  color: #EFDCBC;
}

pre .dos .flow,
pre .diff .change,
pre .python .exception,
pre .python .built_in,
pre .literal,
pre .tex .special {
  color: #EFEFAF;
}

pre .diff .chunk,
pre .ruby .subst {
  color: #8F8F8F;
}

pre .dos .keyword,
pre .python .decorator,
pre .class .title,
pre .haskell .label,
pre .function .title,
pre .ini .title,
pre .diff .header,
pre .ruby .class .parent,
pre .apache .tag,
pre .nginx .built_in,
pre .tex .command,
pre .input_number {
    color: #efef8f;
}

pre .dos .winutils,
pre .ruby .symbol,
pre .ruby .symbol .string,
pre .ruby .symbol .keyword,
pre .ruby .symbol .keymethods,
pre .ruby .string,
pre .ruby .instancevar {
  color: #DCA3A3;
}

pre .diff .deletion,
pre .string,
pre .tag .value,
pre .preprocessor,
pre .built_in,
pre .sql .aggregate,
pre .javadoc,
pre .smalltalk .class,
pre .smalltalk .localvars,
pre .smalltalk .array,
pre .css .rules .value,
pre .attr_selector,
pre .pseudo,
pre .apache .cbracket,
pre .tex .formula {
  color: #CC9393;
}

pre .shebang,
pre .diff .addition,
pre .comment,
pre .java .annotation,
pre .template_comment,
pre .pi,
pre .doctype {
  color: #7F9F7F;
}

pre .xml .css,
pre .xml .javascript,
pre .xml .vbscript,
pre .tex .formula {
  opacity: 0.5;
}


</style>
<style>#wrapper { max-width:900px; margin:0 auto }</style>
</head>
<body class="normal">
  <div id="wrapper">
      <h1 id="reportoflab1jos">Report Of Lab 1, JOS</h1>

<p><strong>1100012713 Siyuan Liu</strong><br/>
5th March, 2014</p>

<h2 id="introduction">Introduction</h2>

<h3 id="checkforthetypeofmymachinewhetheritisani386machine">0.1 Check for the type of my machine, whether it is an i386 machine</h3>

<p>We can type <code>uname -a</code> to check for the type with the following knowledge:</p>

<ul>
<li>i386/i686 denotes the 32-bit</li>
<li>x86&#8211;64 denotes the 64-bit</li>
</ul>

<h3 id="clonethecodesofjostomyhost">0.2 Clone the codes of JOS to my host</h3>

<pre><code>mkdir ~/JOS
cd ~/JOS
git clone http://pdos.csail.mit.edu/6.828/2012/jos.git lab
cd lab
</code></pre>

<p>To do my works, I&#8217;d like to use <code>git</code> to control the versions of my codes.</p>

<h3 id="compilertoolchain">0.3 Compiler Toolchain</h3>

<p>I have to check for whether the tools for compiling are working well. And the handout suggest me to adding the following line to <code>conf/env.mk</code>: this should be added when my machine does not exist the Compiler Tools. However most of the machines with a <code>gcc</code> do not need now.</p>

<pre><code>GCCPREFIX=
</code></pre>

<h3 id="installtheqemu">0.4 Install the Qemu</h3>

<pre><code>git clone http://pdos.csail.mit.edu/6.828/qemu.git -b 6.828-0.15
sudo apt-get install libsdl1.2-dev
./configure --disable-kvm [--prefix=PFX] [--target-list=&quot;i386-softmmu x86_64-softmmu&quot;]
make
make install
</code></pre>

<p>The <code>prefix</code> argument specifies where to install <code>QEMU</code>; without it QEMU will install to <code>/usr/local</code> by default. The <code>target-list</code> argument simply slims down the architectures QEMU will build support for. If use the prefix to control the procedure of installation of qemu, I can not use qemu. In the meantime, target-list is needed to be set. </p>

<p>And I found QEMU Doc: http://wiki.qemu.org/download/qemu-doc.html</p>

<h2 id="part1pcbootstrap">Part 1 PC Bootstrap</h2>

<h3 id="gettingstartedwithx86assembly">1.1 Getting Started with x86 assembly</h3>

<blockquote>
<p><strong>Exercise 1</strong> Familiarize yourself with the assembly language materials available on the 6.828 reference page. You don&#8217;t have to read them now, but you&#8217;ll almost certainly want to refer to some of this material when reading and writing x86 assembly.</p>

<p>We do recommend reading the section &#8220;The Syntax&#8221; in Brennan&#8217;s Guide to Inline Assembly. It gives a good (and quite brief) description of the AT&amp;T assembly syntax we&#8217;ll be using with the GNU assembler in JOS.</p>
</blockquote>

<p>About this exercise, I have done the following things:</p>

<ul>
<li><p>Familar with the PC Assembly Language Book</p>

<p>We will use GNU assembler but this book is written by NASM assembler.</p></li>
</ul>

<p><em>Exercise 1 End</em></p>

<h3 id="simulatingthex86">1.2 Simulating the x86</h3>

<p>In this part, the lab want us to be familar with the <code>qemu</code> and start JOS to see some outcome of the lab1. My classmates and I have thought about why we are supposed to use <code>qemu</code>. And I concluded that qemu can provide VGA display which means that we can see diverse colors by changing the codes(It is just the Challenge of Lab 1).</p>

<h3 id="thepcsphysicaladdressspace">1.3 The PC&#8217;s Physical Address Space</h3>

<table align="center"><tr><td>
<pre>
+------------------+  &lt;- 0xFFFFFFFF (4GB)
|      32-bit      |
|  memory mapped   |
|     devices      |
|                  |
/\/\/\/\/\/\/\/\/\/\

/\/\/\/\/\/\/\/\/\/\
|                  |
|      Unused      |
|                  |
+------------------+  &lt;- depends on amount of RAM
|                  |
|                  |
| Extended Memory  |
|                  |
|                  |
+------------------+  &lt;- 0x00100000 (1MB)
|     BIOS ROM     |
+------------------+  &lt;- 0x000F0000 (960KB)
|  16-bit devices, |
|  expansion ROMs  |
+------------------+  &lt;- 0x000C0000 (768KB)
|   VGA Display    |
+------------------+  &lt;- 0x000A0000 (640KB)
|                  |
|    Low Memory    |
|                  |
+------------------+  &lt;- 0x00000000
</pre>
</td></tr>
</table>

<ul>
<li><p>I got some points about the PC&#8217;s physical address space of JOS:</p>

<ul>
<li>0x00000000~0x000FFFFF: Low Memory only random-access memory (RAM) that an early PC could use;</li>
<li>0x000A0000~0x000FFFFF: used by the hardware, the most import part is BIOS</li>
<li>80286 and 80386 support the 16MB and 4GB, nevertheless they preserve the low address space of 1MB to ensure backward compatibility with existing software. So the address space has a &#8220;hole&#8221;. And address 0x000A0000 divides the space into 2 parts: conventional memory(or low, the first 640KB), extended memory(other part).</li>
<li>At the very top of the space is reserved by the BIOS for some PCI devices.</li>
<li>Now there is 64-bit PC, and it is the same that there must be another hole to keep compatibility with 32-bit PC.</li>
<li>JOS only use 256MB of the first physical address space.</li>
</ul></li>
</ul>

<h3 id="therombios">1.4 The ROM BIOS</h3>

<h5 id="tobeginwithjosiamsupposedtoopentwoterminalwindows:">To begin with JOS, I am supposed to open two terminal windows:</h5>

<ul>
<li><p>make qemu-gdb: start up with qemu, the qemu stops before the processor executes the first instruction and waits for a debugging connection from GDB</p></li>
<li><p>gdb: this gdb links with the gdb. With the operation on this gdb, we can debug with JOS.</p>

<h5 id="whytheqemustartslikethat">Why the qemu starts like that?</h5>

<ul>
<li>The <code>qemu</code> starts at some address, 0xffff0, which is in the ROM BIOS. When the computer power up or reset, the BIOS get the controls and execute first.</li>
<li>The qemu emulator comes with the BIOS</li>
<li>The process first enters into the real mode</li>
<li>There is only 16bytes for the BIOS</li>
</ul></li>
</ul>

<h5 id="aftersomeworktoinitialsomehardwarethebiosreadsthebootloaderfromthediskandtransfercontroltoit.">After some work to initial some hardware, the BIOS reads the boot loader from the disk and transfer control to it.</h5>

<blockquote>
<p><strong>Exercise 2</strong> Use GDB&#8217;s si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing. You might want to look at Phil Storrs I/O Ports Description, as well as other materials on the 6.828 reference materials page. No need to figure out all the details - just the general idea of what the BIOS is doing first. </p>
</blockquote>

<p>About this exercise, I have done the following things:</p>

<ul>
<li>Check for the manual of <code>gdb</code>, and get familiar with some operations, such as <code>si</code>, <code>c</code>, <code>layout split</code>, <code>b</code>, etc.</li>
<li>Take a look a I/O manual, but not much.</li>
</ul>

<p><em>Exercise 2 End</em></p>

<h2 id="part2thebootloader">Part 2 The Boot Loader</h2>

<h3 id="frombiosintobootloader">2.1 From BIOS into boot loader</h3>

<p>We aim to load boot loader into memory, and transfer the control from BIOS to boot loader. So, I&#8217;d to like to list some important points for the boot loader:</p>

<ol>
<li><p>Sectors in disk: it is the unit of disk. The space of reading and writting must align on a sector boundry. </p></li>
<li><p>The first sector in disk is called <code>boot loader</code>. When the BIOS find a bootable hard disk, the first 512 bytes will be loaded into the physical address space from <code>0x7c00</code> to <code>0x7dff</code>. Then the BIOS will use <code>jmp</code> to transfer the control to the boot loader </p></li>
<li>JOS&#8217;s boot loader files are boot.S and main.c

<ul>
<li><code>boot.S</code>: this part of codes is executed in real mode which then transfer to protected mode. Jump into main.c<br/>
At the beginning of the Boot Loader, <code>boot.S</code> set the cr0 to set the real mode. cr0 is a control register, and cr0 controls the condition of the whole system not an indivitual tast.<br/>
Then <code>boot.S</code> transfers the kernel running on protected mode.<br/>
1) Disable the interrupt<br/>
2) Enable the physical address line 20<br/>
3) Switch from real mode to protected mode; still use the GDT and segment translation so the address transmision does not change during the switch<br/>
4) Call bootmain</li>
<li><code>main.c</code>: this part of codes reads kernel in the memory and control the running code to jump into it(at address 0x1000c).<br/>
1) Read 1st page off disk into memory<br/>
2) Load each segment: In disk view, first sector-boot loader(boot.S, main.c), second sector-the kernel of JOS, ELF file.
3) Call the entry point from the ELF header, not return.<br/>
call readseg to get every segment, in redseg, call readsect to get every sector</li>
</ul></li>
<li><p>Aisassembly of the compiled boot loader, get file of obj/boot/boot.asm(actually with kernel) which is loaded at 0x7c00.</p></li>
</ol>

<blockquote>
<p><strong>Exercise 3</strong> Take a look at the lab tools guide, especially the section on GDB commands. Even if you&#8217;re familiar with GDB, this includes some esoteric GDB commands that are useful for OS work.</p>

<p>Set a breakpoint at address 0x7c00, which is where the boot sector will be loaded. Continue execution until that breakpoint. Trace through the code in boot/boot.S, using the source code and the disassembly file obj/boot/boot.asm to keep track of where you are. Also use the x/i command in GDB to disassemble sequences of instructions in the boot loader, and compare the original boot loader source code with both the disassembly in obj/boot/boot.asm and GDB.</p>

<p>Trace into bootmain() in boot/main.c, and then into readsect(). Identify the exact assembly instructions that correspond to each of the statements in readsect(). Trace through the rest of readsect() and back out into bootmain(), and identify the begin and end of the for loop that reads the remaining sectors of the kernel from the disk. Find out what code will run when the loop is finished, set a breakpoint there, and continue to that breakpoint. Then step through the remainder of the boot loader.</p>
</blockquote>

<p>About this exercise, I have done the following things:</p>

<ul>
<li>Continue to get familiar with <code>gdb</code>, make the gdb debugging get into some position of running kernel.</li>
</ul>

<p><em>Exercise 3 End</em></p>

<blockquote>
<p>Be able to answer the following questions: </p>

<ol>
<li>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</li>
<li>What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?</li>
<li>Where is the first instruction of the kernel?</li>
<li>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</li>
</ol>
</blockquote>

<ol>
<li><p>The processor enters boot loader-<code>boot/boot.S</code>, changes the last bit of cr0 to 1. Then the processor switch from 16-bit to 32-bit mode.</p>

<pre><code>44 # Switch from real to protected mode, using a bootstrap GDT
45 # and segment translation that makes virtual addresses 
46 # identical to their physical addresses, so that the 
47 # effective memory map does not change during the switch.
48 lgdt    gdtdesc
49 movl    %cr0, %eax
50 orl     $CR0_PE_ON, %eax
51 movl    %eax, %cr0
</code></pre></li>
<li><p>It is obvious that the last instruction of boot loader is the call for the entry of kernel, which is line 60 in the <code>boot/main.c</code>.</p>

<pre><code>58 // call the entry point from the ELF header
59 // note: does not return!
60 ((void (*)(void)) (ELFHDR-&gt;e_entry))();  
</code></pre></li>
<li><p>We can type <code>objdump -f obj/kern/kernel</code> to get the entry position of kernel. Then I use gdb to stop at 0x10000c to get the first instruction of kernel.</p>

<pre><code>0x10000c:   movw   $0x1234,0x472    
</code></pre></li>
<li><p>The kernel is ELF, so I check the kernel for the details of segments. I type <code>objdump -x obj/kern/kernel</code>: then I can see the size, load address and file off for each segment.</p></li>
</ol>

<h3 id="bootloaderloadsthekernel">2.2 Boot Loader Loads the Kernel</h3>

<p>For this part I&#8217;d like to list some points first which I learnt during reading this part: </p>

<ul>
<li>The process of compiling: .c-&gt;.o object file(binary file which is assembly language), then linker combine the several object file to an ELF file(Executable and Linkable Format)</li>
<li>ELF: <code>objdump -h obj/kern/kernel</code>. In .text segment, there are VMA(link address) and LMA(load address, it is a physical address). In JOS, these two address in boot loader are the same, but in kernel are not.</li>
<li>boot loader and ELF kernel are loaded at 0x7c00 together: We set the link address by passing -Ttext 0x7C00 to the linker in boot/Makefrag.</li>
<li>The entry of ELF is at 0x10000c: <code>objdump -f obj/kern/kernel</code></li>
</ul>

<blockquote>
<p><strong>Exercise 4</strong> Read about programming with pointers in C. The best reference for the C language is The C Programming Language by Brian Kernighan and Dennis Ritchie (known as &#8216;K&amp;R&#8217;). We recommend that students purchase this book (here is an Amazon Link) or find one of MIT&#8217;s 7 copies.</p>

<p>Read 5.1 (Pointers and Addresses) through 5.5 (Character Pointers and Functions) in K&amp;R. Then download the code for pointers.c, run it, and make sure you understand where all of the printed values come from. In particular, make sure you understand where the pointer addresses in lines 1 and 6 come from, how all the values in lines 2 through 4 get there, and why the values printed in line 5 are seemingly corrupted.</p>

<p>There are other references on pointers in C, though not as strongly recommended. A tutorial by Ted Jensen that cites K&amp;R heavily is available in the course readings.</p>

<p>Warning: Unless you are already thoroughly versed in C, do not skip or even skim this reading exercise. If you do not really understand pointers in C, you will suffer untold pain and misery in subsequent labs, and then eventually come to understand them the hard way. Trust us; you don&#8217;t want to find out what &#8220;the hard way&#8221; is.</p>
</blockquote>

<p>About this exercise, I reviewed some knowledge of C language, such C pointers and addresses. </p>

<ul>
<li>The critical view is that the pointer increase or decreace according to their types. For example, if <code>int *a</code>, <code>a+1</code> means that the value of <code>a</code> plus <code>4</code> because <code>a</code> is a <code>int</code> type pointer;</li>
</ul>

<p><em>Exercise 4 End</em></p>

<blockquote>
<p><strong>Exercise 5</strong> Trace through the first few instructions of the boot loader again and identify the first instruction that would &#8220;break&#8221; or otherwise do the wrong thing if you were to get the boot loader&#8217;s link address wrong. Then change the link address in boot/Makefrag to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens. Don&#8217;t forget to change the link address back and make clean again afterward!</p>
</blockquote>

<p>About this exercise, I have done two part of work:</p>

<ol>
<li><p>Assume that the first instruction that would &#8220;break&#8221; is: in <code>obj/boot/boot.asm</code></p>

<pre><code>0x7c29: ljmp    $PROT_MODE_CSEG, $protcseg
</code></pre>

<p>Because when executing the boot loader and transmission from real mode to protected mode, this line involves relative jump which may error if the link address and load address are not accordant. </p></li>
<li><p>Modify the boot loader address which is <code>0x7c00</code> in <code>boot/Makefrag</code> to <code>0x8c00</code>: the processor crashed at</p>

<pre><code>0x7c2d: ljmp   $0x8,$0x8c32 
</code></pre>

<p>The result vertified my assumption. And we can see the jump address is related to the modified link address of boot loader, but the load adress is still 0x7c2d.</p></li>
</ol>

<p><em>Exercise 5 End</em></p>

<blockquote>
<p><strong>Exercise 6</strong> We can examine memory using GDB&#8217;s x command. The GDB manual has full details, but for now, it is enough to know that the command x/Nx ADDR prints N words of memory at ADDR. (Note that both &#8217;x&#8217;s in the command are lowercase.) Warning: The size of a word is not a universal standard. In GNU assembly, a word is two bytes (the &#8216;w&#8217; in xorw, which stands for word, means 2 bytes).</p>

<p>Reset the machine (exit QEMU/GDB and start them again). Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.)</p>
</blockquote>

<p>About this exercise, before loading the ELF kernel, there is some default data at 0x100000. After loading ELF kernel, the content of the kernel is at 0x100000.</p>

<p>I compared the changes at 0x100000 between entering boot loader(entering bootmain) and entering the kernel(finishing reading ELF and enter kernel): it is accordant with my assumption</p>

<pre><code>    (gdb) x/8 0x100000
    0x100000:   add    %al,(%bx,%si)
    0x100002:   add    %al,(%bx,%si)
    0x100004:   add    %al,(%bx,%si)
    0x100006:   add    %al,(%bx,%si)
    0x100008:   add    %al,(%bx,%si)
    0x10000a:   add    %al,(%bx,%si)
    0x10000c:   add    %al,(%bx,%si)
    0x10000e:   add    %al,(%bx,%si)

    (gdb) x/8 0x100000
    0x100000:   add    0x1bad(%eax),%dh
    0x100006:   add    %al,(%eax)
    0x100008:   decb   0x52(%edi)
    0x10000b:   in     $0x66,%al
    0x10000d:   movl   $0xb81234,0x472
    0x100017:   add    %dl,(%ecx)
    0x100019:   add    %cl,(%edi)
    0x10001b:   and    %al,%bl
</code></pre>

<p><em>Exercise 6 End</em></p>

<h2 id="part3thekernel">Part 3 The Kernel</h2>

<h3 id="usingvirtualmemorytoworkaroundpositiondependence">3.1 Using virtual memory to work around position dependence</h3>

<p>For this part I&#8217;d like to list some points first which I learnt during reading this part: </p>

<ul>
<li>Link address: Operating system kernels often like to be linked and run at very high virtual address, such as 0xf0100000, in order to leave the lower part of the processor&#8217;s virtual address space for user programs to use. But many machines do not have the physical space above 0xf0100000. So JOS design the 0xf0100000 to be a virtual address(which denotes the physical address of 0x100000). The low address is used as user address space</li>
<li>The transmision between virtual address and physical address(linear addresses): until the entrypgdir is built, the address transmission will be done by using the &#8216;pages&#8217;.(CR0_PG is set in kern/entry.S, before, boot/boot.S set up the mapping from linear addresses to physical addresses)</li>
<li>Virtual address 0xf0000000 through 0xf0400000 to physical addresses 0x00000000 through 0x00400000, as well as virtual addresses 0x00000000 through 0x00400000 to physical addresses 0x00000000 through 0x00400000. Paging will transfer the low space (below 0xf0400000 which is low space for user) to other space.</li>
</ul>

<blockquote>
<p><strong>Exercise 7</strong> Use QEMU and GDB to trace into the JOS kernel and stop at the movl %eax, %cr0. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened.</p>

<p>What is the first instruction after the new mapping is established that would fail to work properly if the mapping weren&#8217;t in place? Comment out the movl %eax, %cr0 in kern/entry.S, trace into it, and see if you were right.</p>
</blockquote>

<p>About this exercise, we are supposed to check the change from &#8216;no-paging&#8217; to &#8216;paging&#8217;. After cr0 paging is set, the kernel address will be transfered to high space. So, I made some experiment using gdb to check memory content before and after &#8216;paging&#8217; is set.</p>

<pre><code>=&gt; 0x100025:    mov    %eax,%cr0
0x00100025 in ?? ()
(gdb) print *0x100000
$1 = 464367618
(gdb) x/1 0x100000 
0x100000:    add    0x1bad(%eax),%dh
(gdb) x/1 0xf0100000
0xf0100000:  (bad)  


(gdb) si
=&gt; 0x100028:    mov    $0xf010002f,%eax
0x00100028 in ?? ()
(gdb) x/1 0x100000
0x100000:    add    0x1bad(%eax),%dh
(gdb) x/1 0xf0100000
0xf0100000:  add    0x1bad(%eax),%dh
</code></pre>

<p>Actually, the entry of kernel is at 0x10000c. The code text is at 0x10000c, so it is more meaningful to check memory content at 0x10000c. We can type <code>x/1 0x10000c</code> or <code>x/1 0xf010000c</code> into gdb. I am not going to list the result here.</p>

<p><em>Exercise 7 End</em></p>

<h3 id="formattedprintingtotheconsole">3.2 Formatted Printing to the Console</h3>

<p>The <code>monitor.c</code> control the shell, what to display on the screen and the commands of the shell. So the defination of <code>print</code>
 is needed.</p>

<blockquote>
<p><strong>Exercise 8</strong> We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form &#8220;%o&#8221;. Find and fill in this code fragment.</p>
</blockquote>

<p>About this exercise, I am supposed to add a small fragment of code in the function <code>printfmt</code> of <code>lib/printfmt.c</code>. Bacause the function <code>cprintf</code> is a function whose sum of arguments is not uncertain. The compiler help the <code>printf</code> to collect arguments, store them in the memory and provide a pointer pointing to the argument table. </p>

<p>When some function calls <code>cprintf</code>, for example, the <code>console</code> calls <code>cprintf</code>, the &#8216;chain of print&#8217; is <code>cprintf</code>-&gt;<code>vcprintf</code>-&gt;<code>vprintfmt</code>check for argument -&gt; <code>putch</code> output-&gt;<code>cputchar</code>output a character on concole or screen.</p>

<p>So, add some codes below the form &#8220;%o&#8221; in <code>vprintfmt</code> helps the processor to print octal numbers. Similar to the codes of &#8220;%u&#8221;, the work is finished when I just changed the <code>base</code>(denoting scale) to 8.</p>

<pre><code>// (unsigned) octal
case 'o':
num = getuint(&amp;ap, lflag);
base = 8;
goto number; 
</code></pre>

<p><em>Exercise 8 End</em></p>

<blockquote>
<p>Be able to answer the following questions:</p>

<ol>
<li><p>Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</p></li>
<li><p>Explain the a fragment of code from console.c:</p></li>
<li><p>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC&#8217;s calling convention on the x86.
Trace the execution of the following code step-by-step:<br/>
 int x = 1, y = 3, z = 4;<br/>
 cprintf(&#8220;x %d, y %x, z %d\n&#8221;, x, y, z);<br/>
In the call to cprintf(), to what does fmt point? To what does ap point?<br/>
List (in order of execution) each call to cons_putc, va_arg, and vcprintf. For cons_putc, list its argument as well. For va_arg, list what ap points to before and after the call. For vcprintf list the values of its two arguments.</p></li>
<li><p>Run the following code.<br/>
unsigned int i = 0x00646c72;<br/>
cprintf(&#8220;H%x Wo%s&#8221;, 57616, &amp;i);<br/>
What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise. Here&#8217;s an ASCII table that maps bytes to characters.<br/>
The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value? </p></li>
<li><p>In the following code, what is going to be printed after &#8216;y=&#8217;? (note: the answer is not a specific value.) Why does this happen?<br/>
cprintf(&#8220;x=%d y=%d&#8221;, 3);</p></li>
<li><p>Let&#8217;s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change cprintf or its interface so that it would still be possible to pass it a variable number of arguments?</p></li>
</ol>
</blockquote>

<ol>
<li><p>Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c? </p>

<p>kern/console.c provide some interface used to promote the iteraction between the hardware and other program.<br/>
Furthermore, console.c provides kern/printf.c mainly with the cputchar.<br/>
cputchar put a certain char on the screen, which is called by putch in printf.c </p></li>
<li><p>Explain the following from console.c:<br/>
The purpose of this part of code is that check if the screen is full. If so, the program will set the last row to be a row of blank. And it abandons the first row, put the cursor to the start of last row. </p></li>
<li>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC&#8217;s calling convention on the x86.

<ul>
<li>In the call to cprintf(), to what does fmt point? To what does ap point?

<ul>
<li>The fmt points &#8220;x %d, y %x, z %d\n&#8221;</li>
<li>ap points to the the table of variables.</li>
</ul></li>
<li>List (in order of execution) each call to cons_putc, va_arg, and vcprintf. For cons_putc, list its argument as well. For va_arg, list what ap points to before and after the call. For vcprintf list the values of its two arguments.

<ul>
<li>In order of execution: call vcprintf to start the print, and the first character is x, so the printf will put it on the console directly-call cputchar. Then the &#8216;%&#8217; is detected by the function vprintfmt. And vprintfmt continues its step to detect &#8216;d&#8217; which means a output format of signed decimal, then the vprintfmt drives the function printnum to put the num on the console&#8230;Following is similar which I am going to omit.</li>
<li>va_arg(ap, type) is a method of getting next argument of ap with the type. And After calling this function, ap will point to the next argument.</li>
<li>For vcprintf, the first argument fmt is &#8220;x %d, y %x, z %d\n&#8221; and the second ap is a pointer points to the argument table(Which contains x, y, z with their types).</li>
</ul></li>
</ul></li>
<li><p>Run the following code.</p>

<pre><code>unsigned int i = 0x00646c72;  cprintf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</code></pre>

<ul>
<li>I have add these codes into <code>kern/monitor.c</code>, and the output of this String is &#8216;He110 World&#8217;. The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?</li>
<li>If big-endian, the change will effect the convert from the unsighed int i to string, not the output of 57616. (Because whether we use big-endian or little endian, the value of 57616 does not change. But it is different for the transmission from unsigned int to string)</li>
</ul></li>
<li><p>In the following code, what is going to be printed after &#8216;y=&#8217;? (note: the answer is not a specific value.) Why does this happen?</p>

<pre><code>cprintf(&quot;x=%d y=%d&quot;, 3);
</code></pre>

<ul>
<li>(In <code>lib/printfmt.c</code>)The function vprintfmt will find next argument by getint(according to &#8216;%d&#8217;). And we can see, if the argument table ap is not long enough, the ap will return a unknown pointer and we will get a unknown value.</li>
</ul></li>
<li><p>How would you have to change cprintf or its interface so that it would still be possible to pass it a variable number of arguments? </p>

<ul>
<li>We can see that in <code>inc/stdarg.h</code>, the argument table ap is initialized from the last of the argments. It means that JOS has consider the compiler&#8217;s rule of converting arguments-the arguments will be pushed into stack by the order of the argument given. If we change the rule of compiler, we have to initialize the argument table reversely according to the order of the arguments.</li>
</ul></li>
</ol>

<blockquote>
<p><strong>Challenge</strong> Enhance the console to allow text to be printed in different colors. The traditional way to do this is to make it interpret ANSI escape sequences embedded in the text strings printed to the console, but you may use any mechanism you like. There is plenty of information on the 6.828 reference page and elsewhere on the web on programming the VGA display hardware. If you&#8217;re feeling really adventurous, you could try switching the VGA hardware into a graphics mode and making the console draw text onto the graphical frame buffer.</p>
</blockquote>

<p>About this Challenge, first I&#8217;d like to show the procedure of print again: When some function calls <code>cprintf</code>, for example, the <code>console</code> calls <code>cprintf</code>, the &#8216;chain of print&#8217; is <code>cprintf</code>-&gt;<code>vcprintf</code>-&gt;<code>vprintfmt</code>check for argument -&gt; <code>putch</code> output-&gt;<code>cputchar</code>output a character on concole or screen -&gt; <code>cons_putc</code> -&gt; <code>cga_putc</code>.</p>

<p>And we can see the color trick in <code>cga_putc</code>:</p>

<pre><code>// if no attribute given, then use black on white
if (!(c &amp; ~0xFF))
    c |= 0x0700;
</code></pre>

<p>The argument <code>int c</code> has 32 bits, but an character is 8 bits only. So, we can utilize the high bits to add the information of color.</p>

<p>Firstly, bacause I want to use the hight 24 bits, so I need a varible to catch the information of color. I decided to add a global varible <code>int ncolor</code> in <code>lib/printfmt.c</code> to record the color when <code>%C</code> is detected. And I declare <code>int color</code> into <code>kern/console.c</code>, the code is:</p>

<pre><code>static void
cga_putc(int c)
{
    c = c + (ncolor &lt;&lt; 8);
    // if no attribute given, then use black on white
    if (!(c &amp; ~0xFF))
        c |= 0x0700; 
...
</code></pre>

<p>Secondly, I need to finish the most important part-when <code>%C</code> is detected, record the color information,I have regulated the length of corlor information to be 3 bits, like color white to &#8216;wht&#8217; And I have regulated value of color to be 3 bits, like color red to 4. All the color I defined is in lib/printfmt.c. so my critical codes are: </p>

<pre><code>// color
case 'C':
    // Get the color index

    col[0] = *(unsigned char *) fmt++;
    col[1] = *(unsigned char *) fmt++;
    col[2] = *(unsigned char *) fmt++;
    col[3] = '\0';
    // check for the color
    if (col[0] &gt;= '0' &amp;&amp; col[0] &lt;= '9') {
        ncolor = ( (col[0]-'0')*10 + (col[1]-'0') ) * 10 + (col[3]-'0');
    } 
    else {
        if (strcmp (col, &quot;red&quot;) == 0) ncolor = COLOR_RED;
        else if (strcmp (col, &quot;grn&quot;) == 0) ncolor = COLOR_GRN;
        else if (strcmp (col, &quot;blk&quot;) == 0) ncolor = COLOR_BLK;
        else if (strcmp (col, &quot;pur&quot;) == 0) ncolor = COLOR_PUR;
        else if (strcmp (col, &quot;wht&quot;) == 0) ncolor = COLOR_WHT;
        else if (strcmp (col, &quot;gry&quot;) == 0) ncolor = COLOR_GRY;
        else ncolor = COLOR_WHT;
    }
    break;
</code></pre>

<p>Last, display on monitor. I modify the function <code>monitor</code> in <code>kern/monitor.c</code>. I changed the hello words:</p>

<pre><code>cprintf(&quot;%CredWelcome to the %CgrnJOS kernel %Cpurmonitor!\n&quot;);
cprintf(&quot;%CredType %Cgrn'help' for a list of %Cpurcommands.\n&quot;);
</code></pre>

<p>And the result on <code>qemu</code> is:</p>

<figure>
<img src="./color.jpg" alt="" /></figure>



<p><em>Challenge End</em></p>

<h3 id="thestack">3.3 The Stack</h3>

<p>In this part, I am supposed to explore the way C language uses the stack on the x86, and write a useful new kernel monitor function that prints the backtrace of the stack-a series of calls. </p>

<blockquote>
<p><strong>Exercise 9</strong>. Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which &#8220;end&#8221; of this reserved area is the stack pointer initialized to point to?</p>
</blockquote>

<p>I find that the the information of stack is defined in the <code>kern/entry.S</code>. Definately, in the <code>.data segment</code> of the ELF file.The initialization work of stack is that the kernel initialize the <code>ebp</code> to 0, and <code>esp</code> to <code>bootstacktop</code>. And there are bootstack&#8217;s size(KSTKSIZE=32KB) and top position. Another part is <code>bootstacktop</code> denoting the base of the stack, and the stack grows towards low address space.</p>

<p><em>Exercise 9 End</em></p>

<p>The register <code>esp</code>: is the top of the stack which can decreace (Practically, expand the stack) when pushing some value onto the stack, and increace(Practically, shrink the stack) when poping some value off the stack.<br/>
The register <code>ebp</code>: on entry to a C function, the caller saves its base on the stack, and gives its <code>esp</code> in the callee&#8217;s ebp in the duration of the callee&#8217;s function. <code>ebp</code> is useful for backtracing what offend current executing when some panics happen.</p>

<blockquote>
<p><strong>Exercise 10</strong> To become familiar with the C calling conventions on the x86, find the address of the test_backtrace function in obj/kern/kernel.asm, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of test_backtrace push on the stack, and what are those words?</p>

<p>Note that, for this exercise to work properly, you should be using the patched version of QEMU available on the tools page or on Athena. Otherwise, you&#8217;ll have to manually translate all breakpoint and memory addresses to linear addresses.</p>
</blockquote>

<ul>
<li><p>Each time the test_backtrace is called means one more recursive nesting begins. In the meantime, the test_backtrace will get the argument x from the stack which is stored in register <code>ebx</code> temporarily. </p></li>
<li><p>For each recursive nesting level of test_backtrace, there are 32 bytes pushed on stack:</p>

<p><code>push   %ebp</code>: Save the former ebp - 4 bytes<br/>
<code>push   %ebx</code>: Save the ebx bacause in this function ebx is used as a temporary variable. - 4 bytes<br/>
<code>sub    $0x14,%esp</code>: Reverse a stack space of 20 bytes for some varibles. - 20 bytes<br/>
<code>call   f0100040</code>: For saving the register eip(return address). - 4 bytes</p></li>
</ul>

<p>After studying the procedure of call, we leant more details about recursive nesting.</p>

<p><em>Exercise 10 End</em></p>

<blockquote>
<p><strong>Exercise 11</strong> Implement the backtrace function as specified above. Use the same format as in the example, since otherwise the grading script will be confused. When you think you have it working right, run make grade to see if its output conforms to what our grading script expects, and fix it if it doesn&#8217;t. After you have handed in your Lab 1 code, you are welcome to change the output format of the backtrace function any way you like.</p>
</blockquote>

<p>After previous studying, I knew that from top to bottom of stack are:</p>

<ol>
<li>Temporary varible in the callee function</li>
<li>Caller&#8217;s <code>ebp</code></li>
<li>Return address for callee <code>eip</code></li>
<li>Arguments for callee.</li>
</ol>

<p>So, we can call the function <code>read_ebp</code> first to get address of <code>ebp</code>(on stack). Then according to this address, we can get <code>eip</code> and five arguments. Last, we print out these information with the given format. The critical codes are:</p>

<pre><code>int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
    // Lab1 Ex11.   
    uint32_t *ebp, *eip;
    uint32_t arg0, arg1, arg2, arg3, arg4;

    ebp = (uint32_t*) read_ebp();
    eip = (uint32_t*) ebp[1];
    arg0 = ebp[2];
    arg1 = ebp[3];
    arg2 = ebp[4];
    arg3 = ebp[5];
    arg4 = ebp[6];
...
</code></pre>

<p><em>Exercise 11 End</em></p>

<p>Sometimes, backtrace function makes mistakes or is interrupted. At this time, we want some debug information to find the error out. Actually, in many cases, we need the debug information.</p>

<p>There is a function <code>debuginfo_eip</code>, which looks up <code>eip</code> in the symbol table and returns the debugging information for that address. This function is defined in <code>kern/kdebug.c</code>.</p>

<blockquote>
<p><strong>Exercise 12</strong> Modify your stack backtrace function to display, for each eip, the function name, source file name, and line number corresponding to that eip.</p>

<p>In debuginfo_eip, where do _<em>STAB</em>* come from? This question has a long answer; to help you to discover the answer, here are some things you might want to do:</p>

<p>look in the file kern/kernel.ld for _<em>STAB</em>*
run i386-jos-elf-objdump -h obj/kern/kernel
run i386-jos-elf-objdump -G obj/kern/kernel
run i386-jos-elf-gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c, and look at init.s.
see if the bootloader loads the symbol table in memory as part of loading the kernel binary
Complete the implementation of debuginfo_eip by inserting the call to stab_binsearch to find the line number for an address.</p>

<p>Add a backtrace command to the kernel monitor, and extend your implementation of mon_backtrace to call debuginfo_eip and print a line for each stack frame of the form:</p>

<p>K&gt; backtrace
Stack backtrace:
 ebp f010ff78 eip f01008ae args 00000001 f010ff8c 00000000 f0110580 00000000
 kern/monitor.c:143: monitor+106
 ebp f010ffd8 eip f0100193 args 00000000 00001aac 00000660 00000000 00000000
 kern/init.c:49: i386_init+59
 ebp f010fff8 eip f010003d args 00000000 00000000 0000ffff 10cf9a00 0000ffff
 kern/entry.S:70: <unknown>+0
K&gt;
Each line gives the file name and line within that file of the stack frame&#8217;s eip, followed by the name of the function and the offset of the eip from the first instruction of the function (e.g., monitor+106 means the return eip is 106 bytes past the beginning of monitor).</p>

<p>Be sure to print the file and function names on a separate line, to avoid confusing the grading script.</p>

<p>Tip: printf format strings provide an easy, albeit obscure, way to print non-null-terminated strings like those in STABS tables. printf(&#8220;%.*s&#8221;, length, string) prints at most length characters of string. Take a look at the printf man page to find out why this works.</p>

<p>You may find that some functions are missing from the backtrace. For example, you will probably see a call to monitor() but not to runcmd(). This is because the compiler in-lines some function calls. Other optimizations may cause you to see unexpected line numbers. If you get rid of the -O2 from GNUMakefile, the backtraces may make more sense (but your kernel will run more slowly). </p>
</blockquote>

<p>To finish this exercise, there are 3 parts of work we need to do.</p>

<p>Firstly, we need complete the function <code>debuginfo_eip</code>, the fragment code of finding the corresponding line of the given <code>eip</code> is absent. The comment has suggest what to do. We can use the <code>lline</code> and <code>rline</code> gotten below the code to call <code>stab_binsearch</code> to get the line according to <code>addr</code>. The <code>N_SLINE</code> means that we want to get line number from the procedure of <code>stab_binsearch</code>.</p>

<pre><code>...
// Search within [lline, rline] for the line number stab.
// If found, set info-&gt;eip_line to the right line number.
// If not found, return -1.
//
// Hint:
//  There's a particular stabs type used for line numbers.
//  Look at the STABS documentation and &lt;inc/stab.h&gt; to find
//  which one.
stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);

if(lline &lt;= rline)
    info-&gt;eip_line = stabs[lline].n_desc;
else
    return -1;
...
</code></pre>

<p>Secondly, we need add some codes into <code>mon_backtrace</code> to display the debug information. This part is similar to Exercise 12. We just need to add what to display in <code>monitor</code>. The critical codes are:</p>

<pre><code>if (debuginfo_eip((uintptr_t)eip, &amp;info) &lt; 0)
    return -1;
...
cprintf (&quot;         %s:%d: %s+%u\n&quot;, eip_file, eip_line, 
    eip_fn_name, eip_fn_line);
</code></pre>

<p>Last, we are supposed to add the command <code>backtrace</code> into the monitor&#8217;s command list. This part is simple. I found the <code>static struct Command commands[]</code>. And I just added an entity into it:</p>

<pre><code>static struct Command commands[] = {
    { &quot;help&quot;, &quot;Display this list of commands&quot;, mon_help },
    { &quot;kerninfo&quot;, &quot;Display information about the kernel&quot;, mon_kerninfo },
    { &quot;backtrace&quot;, &quot;Display a procedure of backtrace&quot;, mon_backtrace },
};
</code></pre>

<p><em>Exercise 12 End</em></p>

<h2 id="reportoflab1end"><em>Report of Lab 1 End</em></h2>

<script>var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function c(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function j(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function g(t,s){var r="";for(var q=0;q<t.childNodes.length;q++){if(t.childNodes[q].nodeType==3){var p=t.childNodes[q].nodeValue;if(s){p=p.replace(/\n/g,"")}r+=p}else{if(t.childNodes[q].nodeName=="BR"){r+="\n"}else{r+=g(t.childNodes[q])}}}if(/MSIE [678]/.test(navigator.userAgent)){r=r.replace(/\r/g,"\n")}return r}function a(s){var q=s.className.split(/\s+/);q=q.concat(s.parentNode.className.split(/\s+/));for(var p=0;p<q.length;p++){var r=q[p].replace(/^language-/,"");if(d[r]||r=="no-highlight"){return r}}}function b(p){var q=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{q.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);q.push({event:"stop",offset:t,node:s.childNodes[r]})}}}return t})(p,0);return q}function l(y,z,x){var r=0;var w="";var t=[];function u(){if(y.length&&z.length){if(y[0].offset!=z[0].offset){return(y[0].offset<z[0].offset)?y:z}else{return z[0].event=="start"?y:z}}else{return y.length?y:z}}function s(C){var D="<"+C.nodeName.toLowerCase();for(var A=0;A<C.attributes.length;A++){var B=C.attributes[A];D+=" "+B.nodeName.toLowerCase();if(B.nodeValue!=undefined&&B.nodeValue!=false&&B.nodeValue!=null){D+='="'+m(B.nodeValue)+'"'}}return D+">"}while(y.length||z.length){var v=u().splice(0,1)[0];w+=m(x.substr(r,v.offset-r));r=v.offset;if(v.event=="start"){w+=s(v.node);t.push(v.node)}else{if(v.event=="stop"){var q=t.length;do{q--;var p=t[q];w+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);t.splice(q,1);while(q<t.length){w+=s(t[q]);q++}}}}w+=x.substr(r);return w}function i(){function p(u,t,v){if(u.compiled){return}if(!v){u.bR=c(t,u.b?u.b:"\\B|\\b");if(!u.e&&!u.eW){u.e="\\B|\\b"}if(u.e){u.eR=c(t,u.e)}}if(u.i){u.iR=c(t,u.i)}if(u.r==undefined){u.r=1}if(u.k){u.lR=c(t,u.l||hljs.IR,true)}for(var s in u.k){if(!u.k.hasOwnProperty(s)){continue}if(u.k[s] instanceof Object){u.kG=u.k}else{u.kG={keyword:u.k}}break}if(!u.c){u.c=[]}u.compiled=true;for(var r=0;r<u.c.length;r++){p(u.c[r],t,false)}if(u.starts){p(u.starts,t,false)}}for(var q in d){if(!d.hasOwnProperty(q)){continue}p(d[q].dM,d[q],true)}}function e(J,D){if(!i.called){i();i.called=true}function z(r,M){for(var L=0;L<M.c.length;L++){if(M.c[L].bR.test(r)){return M.c[L]}}}function w(L,r){if(C[L].e&&C[L].eR.test(r)){return 1}if(C[L].eW){var M=w(L-1,r);return M?M+1:0}return 0}function x(r,L){return L.iR&&L.iR.test(r)}function A(O,N){var M=[];for(var L=0;L<O.c.length;L++){M.push(O.c[L].b)}var r=C.length-1;do{if(C[r].e){M.push(C[r].e)}r--}while(C[r+1].eW);if(O.i){M.push(O.i)}return c(N,"("+M.join("|")+")",true)}function s(M,L){var N=C[C.length-1];if(!N.t){N.t=A(N,H)}N.t.lastIndex=L;var r=N.t.exec(M);if(r){return[M.substr(L,r.index-L),r[0],false]}else{return[M.substr(L),"",true]}}function p(O,r){var L=H.cI?r[0].toLowerCase():r[0];for(var N in O.kG){if(!O.kG.hasOwnProperty(N)){continue}var M=O.kG[N].hasOwnProperty(L);if(M){return[N,M]}}return false}function F(M,O){if(!O.k){return m(M)}var N="";var P=0;O.lR.lastIndex=0;var L=O.lR.exec(M);while(L){N+=m(M.substr(P,L.index-P));var r=p(O,L);if(r){t+=r[1];N+='<span class="'+r[0]+'">'+m(L[0])+"</span>"}else{N+=m(L[0])}P=O.lR.lastIndex;L=O.lR.exec(M)}N+=m(M.substr(P,M.length-P));return N}function K(r,M){if(M.sL&&d[M.sL]){var L=e(M.sL,r);t+=L.keyword_count;return L.value}else{return F(r,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){q+=L;M.buffer=""}else{if(M.eB){q+=m(r)+L;M.buffer=""}else{q+=L;M.buffer=r}}C.push(M);B+=M.r}function E(O,L,Q){var R=C[C.length-1];if(Q){q+=K(R.buffer+O,R);return false}var M=z(L,R);if(M){q+=K(R.buffer+O,R);I(M,L);return M.rB}var r=w(C.length-1,L);if(r){var N=R.cN?"</span>":"";if(R.rE){q+=K(R.buffer+O,R)+N}else{if(R.eE){q+=K(R.buffer+O,R)+N+m(L)}else{q+=K(R.buffer+O+L,R)+N}}while(r>1){N=C[C.length-2].cN?"</span>":"";q+=N;r--;C.length--}var P=C[C.length-1];C.length--;C[C.length-1].buffer="";if(P.starts){I(P.starts,"")}return R.rE}if(x(L,R)){throw"Illegal"}}var H=d[J];var C=[H.dM];var B=0;var t=0;var q="";try{var v=0;H.dM.buffer="";do{var y=s(D,v);var u=E(y[0],y[1],y[2]);v+=y[0].length;if(!u){v+=y[1].length}}while(!y[2]);if(C.length>1){throw"Illegal"}return{r:B,keyword_count:t,value:q}}catch(G){if(G=="Illegal"){return{r:0,keyword_count:0,value:m(D)}}else{throw G}}}function f(t){var r={keyword_count:0,r:0,value:m(t)};var q=r;for(var p in d){if(!d.hasOwnProperty(p)){continue}var s=e(p,t);s.language=p;if(s.keyword_count+s.r>q.keyword_count+q.r){q=s}if(s.keyword_count+s.r>r.keyword_count+r.r){q=r;r=s}}if(q.language){r.second_best=q}return r}function h(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function o(u,x,q){var y=g(u,q);var s=a(u);if(s=="no-highlight"){return}if(s){var w=e(s,y)}else{var w=f(y);s=w.language}var p=b(u);if(p.length){var r=document.createElement("pre");r.innerHTML=w.value;w.value=l(p,b(r),y)}w.value=h(w.value,x,q);var t=u.className;if(!t.match("(\\s|^)(language-)?"+s+"(\\s|$)")){t=t?(t+" "+s):s}if(/MSIE [678]/.test(navigator.userAgent)&&u.tagName=="CODE"&&u.parentNode.tagName=="PRE"){var r=u.parentNode;var v=document.createElement("div");v.innerHTML="<pre><code>"+w.value+"</code></pre>";u=v.firstChild.firstChild;v.firstChild.cN=r.cN;r.parentNode.replaceChild(v.firstChild,r)}else{u.innerHTML=w.value}u.className=t;u.result={language:s,kw:w.keyword_count,re:w.r};if(w.second_best){u.second_best={language:w.second_best.language,kw:w.second_best.keyword_count,re:w.second_best.r}}}function k(){if(k.called){return}k.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=j(r[p]);if(q){o(q,hljs.tabReplace)}}}function n(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",k,false);window.addEventListener("load",k,false)}else{if(window.attachEvent){window.attachEvent("onload",k)}else{window.onload=k}}}var d={};this.LANGUAGES=d;this.highlight=e;this.highlightAuto=f;this.fixMarkup=h;this.highlightBlock=o;this.initHighlighting=k;this.initHighlightingOnLoad=n;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0x[A-Za-z0-9]+|\\d+(\\.\\d+)?)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.inherit=function(p,s){var r={};for(var q in p){r[q]=p[q]}if(s){for(var q in s){r[q]=s[q]}}return r}}();hljs.LANGUAGES.bash=function(){var d={"true":1,"false":1};var b={cN:"variable",b:"\\$([a-zA-Z0-9_]+)\\b"};var a={cN:"variable",b:"\\$\\{(([^}])|(\\\\}))+\\}",c:[hljs.CNM]};var c={cN:"string",b:'"',e:'"',i:"\\n",c:[hljs.BE,b,a],r:0};var e={cN:"test_condition",b:"",e:"",c:[c,b,a,hljs.CNM],k:{literal:d},r:0};return{dM:{k:{keyword:{"if":1,then:1,"else":1,fi:1,"for":1,"break":1,"continue":1,"while":1,"in":1,"do":1,done:1,echo:1,exit:1,"return":1,set:1,declare:1},literal:d},c:[{cN:"shebang",b:"(#!\\/bin\\/bash)|(#!\\/bin\\/sh)",r:10},hljs.HCM,hljs.CNM,c,b,a,hljs.inherit(e,{b:"\\[ ",e:" \\]",r:0}),hljs.inherit(e,{b:"\\[\\[ ",e:" \\]\\]"})]}}}();hljs.LANGUAGES.cs={dM:{k:{"abstract":1,as:1,base:1,bool:1,"break":1,"byte":1,"case":1,"catch":1,"char":1,checked:1,"class":1,"const":1,"continue":1,decimal:1,"default":1,delegate:1,"do":1,"do":1,"double":1,"else":1,"enum":1,event:1,explicit:1,extern:1,"false":1,"finally":1,fixed:1,"float":1,"for":1,foreach:1,"goto":1,"if":1,implicit:1,"in":1,"int":1,"interface":1,internal:1,is:1,lock:1,"long":1,namespace:1,"new":1,"null":1,object:1,operator:1,out:1,override:1,params:1,"private":1,"protected":1,"public":1,readonly:1,ref:1,"return":1,sbyte:1,sealed:1,"short":1,sizeof:1,stackalloc:1,"static":1,string:1,struct:1,"switch":1,"this":1,"throw":1,"true":1,"try":1,"typeof":1,uint:1,ulong:1,unchecked:1,unsafe:1,ushort:1,using:1,virtual:1,"volatile":1,"void":1,"while":1,ascending:1,descending:1,from:1,get:1,group:1,into:1,join:1,let:1,orderby:1,partial:1,select:1,set:1,value:1,"var":1,where:1,yield:1},c:[{cN:"comment",b:"///",e:"$",rB:true,c:[{cN:"xmlDocTag",b:"///|<!--|-->"},{cN:"xmlDocTag",b:"</?",e:">"}]},hljs.CLCM,hljs.CBLCLM,{cN:"string",b:'@"',e:'"',c:[{b:'""'}]},hljs.ASM,hljs.QSM,hljs.CNM]}};hljs.LANGUAGES.ruby=function(){var g="[a-zA-Z_][a-zA-Z0-9_]*(\\!|\\?)?";var a="[a-zA-Z_]\\w*[!?=]?|[-+~]\\@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?";var n={keyword:{and:1,"false":1,then:1,defined:1,module:1,"in":1,"return":1,redo:1,"if":1,BEGIN:1,retry:1,end:1,"for":1,"true":1,self:1,when:1,next:1,until:1,"do":1,begin:1,unless:1,END:1,rescue:1,nil:1,"else":1,"break":1,undef:1,not:1,"super":1,"class":1,"case":1,require:1,yield:1,alias:1,"while":1,ensure:1,elsif:1,or:1,def:1},keymethods:{__id__:1,__send__:1,abort:1,abs:1,"all?":1,allocate:1,ancestors:1,"any?":1,arity:1,assoc:1,at:1,at_exit:1,autoload:1,"autoload?":1,"between?":1,binding:1,binmode:1,"block_given?":1,call:1,callcc:1,caller:1,capitalize:1,"capitalize!":1,casecmp:1,"catch":1,ceil:1,center:1,chomp:1,"chomp!":1,chop:1,"chop!":1,chr:1,"class":1,class_eval:1,"class_variable_defined?":1,class_variables:1,clear:1,clone:1,close:1,close_read:1,close_write:1,"closed?":1,coerce:1,collect:1,"collect!":1,compact:1,"compact!":1,concat:1,"const_defined?":1,const_get:1,const_missing:1,const_set:1,constants:1,count:1,crypt:1,"default":1,default_proc:1,"delete":1,"delete!":1,delete_at:1,delete_if:1,detect:1,display:1,div:1,divmod:1,downcase:1,"downcase!":1,downto:1,dump:1,dup:1,each:1,each_byte:1,each_index:1,each_key:1,each_line:1,each_pair:1,each_value:1,each_with_index:1,"empty?":1,entries:1,eof:1,"eof?":1,"eql?":1,"equal?":1,"eval":1,exec:1,exit:1,"exit!":1,extend:1,fail:1,fcntl:1,fetch:1,fileno:1,fill:1,find:1,find_all:1,first:1,flatten:1,"flatten!":1,floor:1,flush:1,for_fd:1,foreach:1,fork:1,format:1,freeze:1,"frozen?":1,fsync:1,getc:1,gets:1,global_variables:1,grep:1,gsub:1,"gsub!":1,"has_key?":1,"has_value?":1,hash:1,hex:1,id:1,include:1,"include?":1,included_modules:1,index:1,indexes:1,indices:1,induced_from:1,inject:1,insert:1,inspect:1,instance_eval:1,instance_method:1,instance_methods:1,"instance_of?":1,"instance_variable_defined?":1,instance_variable_get:1,instance_variable_set:1,instance_variables:1,"integer?":1,intern:1,invert:1,ioctl:1,"is_a?":1,isatty:1,"iterator?":1,join:1,"key?":1,keys:1,"kind_of?":1,lambda:1,last:1,length:1,lineno:1,ljust:1,load:1,local_variables:1,loop:1,lstrip:1,"lstrip!":1,map:1,"map!":1,match:1,max:1,"member?":1,merge:1,"merge!":1,method:1,"method_defined?":1,method_missing:1,methods:1,min:1,module_eval:1,modulo:1,name:1,nesting:1,"new":1,next:1,"next!":1,"nil?":1,nitems:1,"nonzero?":1,object_id:1,oct:1,open:1,pack:1,partition:1,pid:1,pipe:1,pop:1,popen:1,pos:1,prec:1,prec_f:1,prec_i:1,print:1,printf:1,private_class_method:1,private_instance_methods:1,"private_method_defined?":1,private_methods:1,proc:1,protected_instance_methods:1,"protected_method_defined?":1,protected_methods:1,public_class_method:1,public_instance_methods:1,"public_method_defined?":1,public_methods:1,push:1,putc:1,puts:1,quo:1,raise:1,rand:1,rassoc:1,read:1,read_nonblock:1,readchar:1,readline:1,readlines:1,readpartial:1,rehash:1,reject:1,"reject!":1,remainder:1,reopen:1,replace:1,require:1,"respond_to?":1,reverse:1,"reverse!":1,reverse_each:1,rewind:1,rindex:1,rjust:1,round:1,rstrip:1,"rstrip!":1,scan:1,seek:1,select:1,send:1,set_trace_func:1,shift:1,singleton_method_added:1,singleton_methods:1,size:1,sleep:1,slice:1,"slice!":1,sort:1,"sort!":1,sort_by:1,split:1,sprintf:1,squeeze:1,"squeeze!":1,srand:1,stat:1,step:1,store:1,strip:1,"strip!":1,sub:1,"sub!":1,succ:1,"succ!":1,sum:1,superclass:1,swapcase:1,"swapcase!":1,sync:1,syscall:1,sysopen:1,sysread:1,sysseek:1,system:1,syswrite:1,taint:1,"tainted?":1,tell:1,test:1,"throw":1,times:1,to_a:1,to_ary:1,to_f:1,to_hash:1,to_i:1,to_int:1,to_io:1,to_proc:1,to_s:1,to_str:1,to_sym:1,tr:1,"tr!":1,tr_s:1,"tr_s!":1,trace_var:1,transpose:1,trap:1,truncate:1,"tty?":1,type:1,ungetc:1,uniq:1,"uniq!":1,unpack:1,unshift:1,untaint:1,untrace_var:1,upcase:1,"upcase!":1,update:1,upto:1,"value?":1,values:1,values_at:1,warn:1,write:1,write_nonblock:1,"zero?":1,zip:1}};var h={cN:"yardoctag",b:"@[A-Za-z]+"};var d={cN:"comment",b:"#",e:"$",c:[h]};var c={cN:"comment",b:"^\\=begin",e:"^\\=end",c:[h],r:10};var b={cN:"comment",b:"^__END__",e:"\\n$"};var u={cN:"subst",b:"#\\{",e:"}",l:g,k:n};var p=[hljs.BE,u];var s={cN:"string",b:"'",e:"'",c:p,r:0};var r={cN:"string",b:'"',e:'"',c:p,r:0};var q={cN:"string",b:"%[qw]?\\(",e:"\\)",c:p,r:10};var o={cN:"string",b:"%[qw]?\\[",e:"\\]",c:p,r:10};var m={cN:"string",b:"%[qw]?{",e:"}",c:p,r:10};var l={cN:"string",b:"%[qw]?<",e:">",c:p,r:10};var k={cN:"string",b:"%[qw]?/",e:"/",c:p,r:10};var j={cN:"string",b:"%[qw]?%",e:"%",c:p,r:10};var i={cN:"string",b:"%[qw]?-",e:"-",c:p,r:10};var t={cN:"string",b:"%[qw]?\\|",e:"\\|",c:p,r:10};var e={cN:"function",b:"\\bdef\\s+",e:" |$|;",l:g,k:n,c:[{cN:"title",b:a,l:g,k:n},{cN:"params",b:"\\(",e:"\\)",l:g,k:n},d,c,b]};var f={cN:"identifier",b:g,l:g,k:n,r:0};var v=[d,c,b,s,r,q,o,m,l,k,j,i,t,{cN:"class",b:"\\b(class|module)\\b",e:"$|;",k:{"class":1,module:1},c:[{cN:"title",b:"[A-Za-z_]\\w*(::\\w+)*(\\?|\\!)?",r:0},{cN:"inheritance",b:"<\\s*",c:[{cN:"parent",b:"("+hljs.IR+"::)?"+hljs.IR}]},d,c,b]},e,{cN:"constant",b:"(::)?([A-Z]\\w*(::)?)+",r:0},{cN:"symbol",b:":",c:[s,r,q,o,m,l,k,j,i,t,f],r:0},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{cN:"number",b:"\\?\\w"},{cN:"variable",b:"(\\$\\W)|((\\$|\\@\\@?)(\\w+))"},f,{b:"("+hljs.RSR+")\\s*",c:[d,c,b,{cN:"regexp",b:"/",e:"/[a-z]*",i:"\\n",c:[hljs.BE]}],r:0}];u.c=v;e.c[1].c=v;return{dM:{l:g,k:n,c:v}}}();hljs.LANGUAGES.diff={cI:true,dM:{c:[{cN:"chunk",b:"^\\@\\@ +\\-\\d+,\\d+ +\\+\\d+,\\d+ +\\@\\@$",r:10},{cN:"chunk",b:"^\\*\\*\\* +\\d+,\\d+ +\\*\\*\\*\\*$",r:10},{cN:"chunk",b:"^\\-\\-\\- +\\d+,\\d+ +\\-\\-\\-\\-$",r:10},{cN:"header",b:"Index: ",e:"$"},{cN:"header",b:"=====",e:"=====$"},{cN:"header",b:"^\\-\\-\\-",e:"$"},{cN:"header",b:"^\\*{3} ",e:"$"},{cN:"header",b:"^\\+\\+\\+",e:"$"},{cN:"header",b:"\\*{5}",e:"\\*{5}$"},{cN:"addition",b:"^\\+",e:"$"},{cN:"deletion",b:"^\\-",e:"$"},{cN:"change",b:"^\\!",e:"$"}]}};hljs.LANGUAGES.javascript={dM:{k:{keyword:{"in":1,"if":1,"for":1,"while":1,"finally":1,"var":1,"new":1,"function":1,"do":1,"return":1,"void":1,"else":1,"break":1,"catch":1,"instanceof":1,"with":1,"throw":1,"case":1,"default":1,"try":1,"this":1,"switch":1,"continue":1,"typeof":1,"delete":1},literal:{"true":1,"false":1,"null":1}},c:[hljs.ASM,hljs.QSM,hljs.CLCM,hljs.CBLCLM,hljs.CNM,{b:"("+hljs.RSR+"|case|return|throw)\\s*",k:{"return":1,"throw":1,"case":1},c:[hljs.CLCM,hljs.CBLCLM,{cN:"regexp",b:"/",e:"/[gim]*",c:[{b:"\\\\/"}]}],r:0},{cN:"function",b:"\\bfunction\\b",e:"{",k:{"function":1},c:[{cN:"title",b:"[A-Za-z$_][0-9A-Za-z$_]*"},{cN:"params",b:"\\(",e:"\\)",c:[hljs.ASM,hljs.QSM,hljs.CLCM,hljs.CBLCLM]}]}]}};hljs.LANGUAGES.css=function(){var a={cN:"function",b:hljs.IR+"\\(",e:"\\)",c:[{eW:true,eE:true,c:[hljs.NM,hljs.ASM,hljs.QSM]}]};return{cI:true,dM:{i:"[=/|']",c:[hljs.CBLCLM,{cN:"id",b:"\\#[A-Za-z0-9_-]+"},{cN:"class",b:"\\.[A-Za-z0-9_-]+",r:0},{cN:"attr_selector",b:"\\[",e:"\\]",i:"$"},{cN:"pseudo",b:":(:)?[a-zA-Z0-9\\_\\-\\+\\(\\)\\\"\\']+"},{cN:"at_rule",b:"@(font-face|page)",l:"[a-z-]+",k:{"font-face":1,page:1}},{cN:"at_rule",b:"@",e:"[{;]",eE:true,k:{"import":1,page:1,media:1,charset:1},c:[a,hljs.ASM,hljs.QSM,hljs.NM]},{cN:"tag",b:hljs.IR,r:0},{cN:"rules",b:"{",e:"}",i:"[^\\s]",r:0,c:[hljs.CBLCLM,{cN:"rule",b:"[^\\s]",rB:true,e:";",eW:true,c:[{cN:"attribute",b:"[A-Z\\_\\.\\-]+",e:":",eE:true,i:"[^\\s]",starts:{cN:"value",eW:true,eE:true,c:[a,hljs.NM,hljs.QSM,hljs.ASM,hljs.CBLCLM,{cN:"hexcolor",b:"\\#[0-9A-F]+"},{cN:"important",b:"!important"}]}}]}]}]}}}();hljs.LANGUAGES.xml=function(){var b="[A-Za-z0-9\\._:-]+";var a={eW:true,c:[{cN:"attribute",b:b,r:0},{b:'="',rB:true,e:'"',c:[{cN:"value",b:'"',eW:true}]},{b:"='",rB:true,e:"'",c:[{cN:"value",b:"'",eW:true}]},{b:"=",c:[{cN:"value",b:"[^\\s/>]+"}]}]};return{cI:true,dM:{c:[{cN:"pi",b:"<\\?",e:"\\?>",r:10},{cN:"doctype",b:"<!DOCTYPE",e:">",r:10,c:[{b:"\\[",e:"\\]"}]},{cN:"comment",b:"<!--",e:"-->",r:10},{cN:"cdata",b:"<\\!\\[CDATA\\[",e:"\\]\\]>",r:10},{cN:"tag",b:"<style",e:">",k:{title:{style:1}},c:[a],starts:{cN:"css",e:"</style>",rE:true,sL:"css"}},{cN:"tag",b:"<script",e:">",k:{title:{script:1}},c:[a],starts:{cN:"javascript",e:"<\/script>",rE:true,sL:"javascript"}},{cN:"vbscript",b:"<%",e:"%>",sL:"vbscript"},{cN:"tag",b:"</?",e:"/?>",c:[{cN:"title",b:"[^ />]+"},a]}]}}}();hljs.LANGUAGES.java={dM:{k:{"false":1,"synchronized":1,"int":1,"abstract":1,"float":1,"private":1,"char":1,"interface":1,"boolean":1,"static":1,"null":1,"if":1,"const":1,"for":1,"true":1,"while":1,"long":1,"throw":1,strictfp:1,"finally":1,"protected":1,"extends":1,"import":1,"native":1,"final":1,"implements":1,"return":1,"void":1,"enum":1,"else":1,"break":1,"transient":1,"new":1,"catch":1,"instanceof":1,"byte":1,"super":1,"class":1,"volatile":1,"case":1,assert:1,"short":1,"package":1,"default":1,"double":1,"public":1,"try":1,"this":1,"switch":1,"continue":1,"throws":1},c:[{cN:"javadoc",b:"/\\*\\*",e:"\\*/",c:[{cN:"javadoctag",b:"@[A-Za-z]+"}],r:10},hljs.CLCM,hljs.CBLCLM,hljs.ASM,hljs.QSM,{cN:"class",b:"(class |interface )",e:"{",k:{"class":1,"interface":1},i:":",c:[{b:"(implements|extends)",k:{"extends":1,"implements":1},r:10},{cN:"title",b:hljs.UIR}]},hljs.CNM,{cN:"annotation",b:"@[A-Za-z]+"}]}};hljs.LANGUAGES.php={cI:true,dM:{k:{and:1,include_once:1,list:1,"abstract":1,global:1,"private":1,echo:1,"interface":1,as:1,"static":1,endswitch:1,array:1,"null":1,"if":1,endwhile:1,or:1,"const":1,"for":1,endforeach:1,self:1,"var":1,"while":1,isset:1,"public":1,"protected":1,exit:1,foreach:1,"throw":1,elseif:1,"extends":1,include:1,__FILE__:1,empty:1,require_once:1,"function":1,"do":1,xor:1,"return":1,"implements":1,parent:1,clone:1,use:1,__CLASS__:1,__LINE__:1,"else":1,"break":1,print:1,"eval":1,"new":1,"catch":1,__METHOD__:1,"class":1,"case":1,exception:1,php_user_filter:1,"default":1,die:1,require:1,__FUNCTION__:1,enddeclare:1,"final":1,"try":1,"this":1,"switch":1,"continue":1,endfor:1,endif:1,declare:1,unset:1,"true":1,"false":1,namespace:1},c:[hljs.CLCM,hljs.HCM,{cN:"comment",b:"/\\*",e:"\\*/",c:[{cN:"phpdoc",b:"\\s@[A-Za-z]+",r:10}]},hljs.CNM,hljs.inherit(hljs.ASM,{i:null}),hljs.inherit(hljs.QSM,{i:null}),{cN:"variable",b:"\\$[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*"},{cN:"preprocessor",b:"<\\?php",r:10},{cN:"preprocessor",b:"\\?>"}]}};hljs.LANGUAGES.python=function(){var c={cN:"string",b:"(u|b)?r?'''",e:"'''",r:10};var b={cN:"string",b:'(u|b)?r?"""',e:'"""',r:10};var a={cN:"string",b:"(u|r|ur|b|br)'",e:"'",c:[hljs.BE],r:10};var f={cN:"string",b:'(u|r|ur|b|br)"',e:'"',c:[hljs.BE],r:10};var d={cN:"title",b:hljs.UIR};var e={cN:"params",b:"\\(",e:"\\)",c:[c,b,a,f,hljs.ASM,hljs.QSM]};return{dM:{k:{keyword:{and:1,elif:1,is:1,global:1,as:1,"in":1,"if":1,from:1,raise:1,"for":1,except:1,"finally":1,print:1,"import":1,pass:1,"return":1,exec:1,"else":1,"break":1,not:1,"with":1,"class":1,assert:1,yield:1,"try":1,"while":1,"continue":1,del:1,or:1,def:1,lambda:1,nonlocal:10},built_in:{None:1,True:1,False:1,Ellipsis:1,NotImplemented:1}},i:"(</|->|\\?)",c:[hljs.HCM,c,b,a,f,hljs.ASM,hljs.QSM,{cN:"function",b:"\\bdef ",e:":",i:"$",k:{def:1},c:[d,e],r:10},{cN:"class",b:"\\bclass ",e:":",i:"[${]",k:{"class":1},c:[d,e],r:10},hljs.CNM,{cN:"decorator",b:"@",e:"$"}]}}}();hljs.LANGUAGES.sql={cI:true,dM:{i:"[^\\s]",c:[{cN:"operator",b:"(begin|start|commit|rollback|savepoint|lock|alter|create|drop|rename|call|delete|do|handler|insert|load|replace|select|truncate|update|set|show|pragma)\\b",e:";|$",k:{keyword:{all:1,partial:1,global:1,month:1,current_timestamp:1,using:1,go:1,revoke:1,smallint:1,indicator:1,"end-exec":1,disconnect:1,zone:1,"with":1,character:1,assertion:1,to:1,add:1,current_user:1,usage:1,input:1,local:1,alter:1,match:1,collate:1,real:1,then:1,rollback:1,get:1,read:1,timestamp:1,session_user:1,not:1,integer:1,bit:1,unique:1,day:1,minute:1,desc:1,insert:1,execute:1,like:1,ilike:2,level:1,decimal:1,drop:1,"continue":1,isolation:1,found:1,where:1,constraints:1,domain:1,right:1,national:1,some:1,module:1,transaction:1,relative:1,second:1,connect:1,escape:1,close:1,system_user:1,"for":1,deferred:1,section:1,cast:1,current:1,sqlstate:1,allocate:1,intersect:1,deallocate:1,numeric:1,"public":1,preserve:1,full:1,"goto":1,initially:1,asc:1,no:1,key:1,output:1,collation:1,group:1,by:1,union:1,session:1,both:1,last:1,language:1,constraint:1,column:1,of:1,space:1,foreign:1,deferrable:1,prior:1,connection:1,unknown:1,action:1,commit:1,view:1,or:1,first:1,into:1,"float":1,year:1,primary:1,cascaded:1,except:1,restrict:1,set:1,references:1,names:1,table:1,outer:1,open:1,select:1,size:1,are:1,rows:1,from:1,prepare:1,distinct:1,leading:1,create:1,only:1,next:1,inner:1,authorization:1,schema:1,corresponding:1,option:1,declare:1,precision:1,immediate:1,"else":1,timezone_minute:1,external:1,varying:1,translation:1,"true":1,"case":1,exception:1,join:1,hour:1,"default":1,"double":1,scroll:1,value:1,cursor:1,descriptor:1,values:1,dec:1,fetch:1,procedure:1,"delete":1,and:1,"false":1,"int":1,is:1,describe:1,"char":1,as:1,at:1,"in":1,varchar:1,"null":1,trailing:1,any:1,absolute:1,current_time:1,end:1,grant:1,privileges:1,when:1,cross:1,check:1,write:1,current_date:1,pad:1,begin:1,temporary:1,exec:1,time:1,update:1,catalog:1,user:1,sql:1,date:1,on:1,identity:1,timezone_hour:1,natural:1,whenever:1,interval:1,work:1,order:1,cascade:1,diagnostics:1,nchar:1,having:1,left:1,call:1,"do":1,handler:1,load:1,replace:1,truncate:1,start:1,lock:1,show:1,pragma:1},aggregate:{count:1,sum:1,min:1,max:1,avg:1}},c:[{cN:"string",b:"'",e:"'",c:[hljs.BE,{b:"''"}],r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE,{b:'""'}],r:0},{cN:"string",b:"`",e:"`",c:[hljs.BE]},hljs.CNM,{b:"\\n"}]},hljs.CBLCLM,{cN:"comment",b:"--",e:"$"}]}};hljs.LANGUAGES.ini={cI:true,dM:{i:"[^\\s]",c:[{cN:"comment",b:";",e:"$"},{cN:"title",b:"^\\[",e:"\\]"},{cN:"setting",b:"^[a-z0-9_\\[\\]]+[ \\t]*=[ \\t]*",e:"$",c:[{cN:"value",eW:true,k:{on:1,off:1,"true":1,"false":1,yes:1,no:1},c:[hljs.QSM,hljs.NM]}]}]}};hljs.LANGUAGES.perl=function(){var c={getpwent:1,getservent:1,quotemeta:1,msgrcv:1,scalar:1,kill:1,dbmclose:1,undef:1,lc:1,ma:1,syswrite:1,tr:1,send:1,umask:1,sysopen:1,shmwrite:1,vec:1,qx:1,utime:1,local:1,oct:1,semctl:1,localtime:1,readpipe:1,"do":1,"return":1,format:1,read:1,sprintf:1,dbmopen:1,pop:1,getpgrp:1,not:1,getpwnam:1,rewinddir:1,qq:1,fileno:1,qw:1,endprotoent:1,wait:1,sethostent:1,bless:1,s:1,opendir:1,"continue":1,each:1,sleep:1,endgrent:1,shutdown:1,dump:1,chomp:1,connect:1,getsockname:1,die:1,socketpair:1,close:1,flock:1,exists:1,index:1,shmget:1,sub:1,"for":1,endpwent:1,redo:1,lstat:1,msgctl:1,setpgrp:1,abs:1,exit:1,select:1,print:1,ref:1,gethostbyaddr:1,unshift:1,fcntl:1,syscall:1,"goto":1,getnetbyaddr:1,join:1,gmtime:1,symlink:1,semget:1,splice:1,x:1,getpeername:1,recv:1,log:1,setsockopt:1,cos:1,last:1,reverse:1,gethostbyname:1,getgrnam:1,study:1,formline:1,endhostent:1,times:1,chop:1,length:1,gethostent:1,getnetent:1,pack:1,getprotoent:1,getservbyname:1,rand:1,mkdir:1,pos:1,chmod:1,y:1,substr:1,endnetent:1,printf:1,next:1,open:1,msgsnd:1,readdir:1,use:1,unlink:1,getsockopt:1,getpriority:1,rindex:1,wantarray:1,hex:1,system:1,getservbyport:1,endservent:1,"int":1,chr:1,untie:1,rmdir:1,prototype:1,tell:1,listen:1,fork:1,shmread:1,ucfirst:1,setprotoent:1,"else":1,sysseek:1,link:1,getgrgid:1,shmctl:1,waitpid:1,unpack:1,getnetbyname:1,reset:1,chdir:1,grep:1,split:1,require:1,caller:1,lcfirst:1,until:1,warn:1,"while":1,values:1,shift:1,telldir:1,getpwuid:1,my:1,getprotobynumber:1,"delete":1,and:1,sort:1,uc:1,defined:1,srand:1,accept:1,"package":1,seekdir:1,getprotobyname:1,semop:1,our:1,rename:1,seek:1,"if":1,q:1,chroot:1,sysread:1,setpwent:1,no:1,crypt:1,getc:1,chown:1,sqrt:1,write:1,setnetent:1,setpriority:1,foreach:1,tie:1,sin:1,msgget:1,map:1,stat:1,getlogin:1,unless:1,elsif:1,truncate:1,exec:1,keys:1,glob:1,tied:1,closedir:1,ioctl:1,socket:1,readlink:1,"eval":1,xor:1,readline:1,binmode:1,setservent:1,eof:1,ord:1,bind:1,alarm:1,pipe:1,atan2:1,getgrent:1,exp:1,time:1,push:1,setgrent:1,gt:1,lt:1,or:1,ne:1,m:1};var d={cN:"subst",b:"[$@]\\{",e:"}",k:c,r:10};var b={cN:"variable",b:"\\$\\d"};var a={cN:"variable",b:"[\\$\\%\\@\\*](\\^\\w\\b|#\\w+(\\:\\:\\w+)*|[^\\s\\w{]|{\\w+}|\\w+(\\:\\:\\w*)*)"};var g=[hljs.BE,d,b,a];var f={b:"->",c:[{b:hljs.IR},{b:"{",e:"}"}]};var e=[b,a,hljs.HCM,{cN:"comment",b:"^(__END__|__DATA__)",e:"\\n$",r:5},f,{cN:"string",b:"q[qwxr]?\\s*\\(",e:"\\)",c:g,r:5},{cN:"string",b:"q[qwxr]?\\s*\\[",e:"\\]",c:g,r:5},{cN:"string",b:"q[qwxr]?\\s*\\{",e:"\\}",c:g,r:5},{cN:"string",b:"q[qwxr]?\\s*\\|",e:"\\|",c:g,r:5},{cN:"string",b:"q[qwxr]?\\s*\\<",e:"\\>",c:g,r:5},{cN:"string",b:"qw\\s+q",e:"q",c:g,r:5},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"string",b:'"',e:'"',c:g,r:0},{cN:"string",b:"`",e:"`",c:[hljs.BE]},{cN:"string",b:"{\\w+}",r:0},{cN:"string",b:"-?\\w+\\s*\\=\\>",r:0},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{cN:"regexp",b:"(s|tr|y)/(\\\\.|[^/])*/(\\\\.|[^/])*/[a-z]*",r:10},{cN:"regexp",b:"(m|qr)?/",e:"/[a-z]*",c:[hljs.BE],r:0},{cN:"sub",b:"\\bsub\\b",e:"(\\s*\\(.*?\\))?[;{]",k:{sub:1},r:5},{cN:"operator",b:"-\\w\\b",r:0},{cN:"pod",b:"\\=\\w",e:"\\=cut"}];d.c=e;f.c[1].c=e;return{dM:{k:c,c:e}}}();hljs.LANGUAGES.cpp=function(){var b={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};var a={cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:b,r:10};a.c=[a];return{dM:{k:b,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'",e:"[^\\\\]'",i:"[^\\\\][^']"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},a]}}}();</script>

<script>hljs.initHighlightingOnLoad();</script>
    </div>
</body>
</html>